#!/bin/bash

# Master script for running annotation pipeline

# Usage message
usage() { printf "
..... Annotation pipeline .....
........ Version 0.0.1 ........
......... Jakob Russel ........
........... 2019 May ..........

Usage:
 ./annotate [-i my.fasta] [-o /my/output/dir]

Optional arguments:
[-c /path/to/alternative/config/file] Change the config.yml file to change specific options in the different tools (default: /mibi/users/russel/Software/annotation/config.yml)
[-r] resume (e.g. to add new annotation tools or create new output table with different e-value cutoffs)

Arguments to add tools:
[-d] Adds dbcan2 for CAZyme and CAZyme Gene Cluster (CGC) prediction
[-e <e-value>] Adds eggNOG for KEGG orthologs and annotations. Choose e-value cutoff
[-n] Adds RGI for Antibiotic resistance prediction against CARD
[-m <e-value>] Adds diamond search against MEROPS database for peptidase prediction. Choose e-value cutoff
[-a] Adds antiSMASH prediction for secondary metabolite production
[-k <e-value>] Adds KOfam_scan for KEGG orthologs and annotations. Choose e-value cutoff
[-s <string>] Adds SignalP prediction. Choose organism: arch, gram+, or gram-

Example:
 ./annotate -i my.fasta -o /my/output/dir -d -e 1e-10 -n -m 1e-20 -a -r -k 1e-10 -s gram+

" 1>&2; exit 1; }
GREEN=$(tput setaf 2)
NORM=$(tput sgr0)

CLI=$*
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

# Get arguments
RESUME=false
DBCAN=false
ANTISMASH=false
RGI=false

while getopts ":o:i:c:k:m:s:e:rdan" opt
do
  case $opt in
    o) OUT="$OPTARG";;
    i) FAS="$OPTARG";;
    c) CONFIG="$OPTARG";;
    r) RESUME=true;;
    k) KOFAM="$OPTARG";;
    d) DBCAN=true;;
    e) EGGNOG="$OPTARG";;
    m) MEROPS="$OPTARG";;
    s) SIGNALP="$OPTARG";;
    a) ANTISMASH=true;;
    n) RGI=true;;
    :) echo "Missing option argument for -$OPTARG"; usage;;
    *) usage;;
  esac
done

shift $((OPTIND-1))

# Check arguments
if [ -z "${OUT}" ] || [ -z "${FAS}" ]
then
    usage
fi

if [ -z "${CONFIG}" ]
then
    CONFIG="${DIR}/config.yml"
fi

if ! [[ "${OUT}" == /* ]]
then
	OUT=${PWD}/${OUT}
fi

# Check output dir
if [ -d "$OUT" ] && ! "$RESUME"
then
    	printf "Output directory already exists! Terminating\nUse [-r] argument to add tools to existing dir and/or remake output with new e-value cutoffs\n"
	exit 1
else
	mkdir -p $OUT
fi

# Run Prokka
if [ -d "${OUT}/prokka" ]
then
	echo "${GREEN}prokka has already been run. Skipping${NORM}"
else
	mkdir ${OUT}/tmp
	echo "${GREEN}Running Prokka${NORM}"
	THIS=$(grep "prokka: " $CONFIG \
        	| awk '{$1=""; print $0}' \
        	| sed "s@ANNOTATION_OUT@${OUT}/prokka@;s@ANNOTATION_FAS@${FAS}@")
	$THIS
fi

if ! [ -f "${OUT}/prokka/"*.faa ]
then
	echo Prokka failed. Terminating
	exit 1
fi

# Run KOfam scan
if ! [ -z "$KOFAM" ]
then
	if [ -d "$OUT/kofam" ]
	then
		echo "${GREEN}KOfam scan has already been run. Skipping${NORM}"
	else
		echo "${GREEN}Running KOfam scan${NORM}"
		THIS=$(grep "kofam: " $CONFIG \
	        	| awk '{$1=""; print $0}' \
	        	| sed "s@ANNOTATION_OUT@${OUT}/results@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_TMP@${OUT}/tmp@")
		$THIS
		mkdir ${OUT}/kofam
		mv ${OUT}/results ${OUT}/kofam/results
		mv ${OUT}/tmp/tabular/ ${OUT}/kofam
	fi
fi

# Run dbCAN2
if "$DBCAN"
then
        if [ -d "$OUT/dbcan2" ]
        then
                echo "${GREEN}dbCAN2 has already been run. Skipping${NORM}"
        else
                echo "${GREEN}Running dbCAN2${NORM}"
		grep "ID=" ${OUT}/prokka/*\.gff > ${OUT}/prokka/trimmed.gff2
		mkdir ${OUT}/dbcan2
                THIS=$(grep "dbcan: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/dbcan2@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_GFF@${OUT}/prokka/trimmed.gff2@")
                $THIS
        fi
fi

# Run eggNOG
if ! [ -z "$EGGNOG" ]
then
        if [ -d "$OUT/eggnog" ]
        then
                echo "${GREEN}eggNOG-mapper has already been run. Skipping${NORM}"
        else
                echo "${GREEN}Running eggNOG-mapper. Warning! This is slow!${NORM}"
                mkdir ${OUT}/eggnog
                THIS=$(grep "eggnog: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/eggnog@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_TMP@${OUT}/tmp@")
                $THIS
        fi
fi

# Run MEROPS
if ! [ -z "$MEROPS" ]
then
        if [ -d "$OUT/merops" ]
        then
                echo "${GREEN}Merops search has already been run. Skipping${NORM}"
        else
		mkdir ${OUT}/merops
                echo "${GREEN}Running diamond search against MEROPS${NORM}"
                THIS=$(grep "merops: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/merops/matches.m8@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@")
                $THIS
        fi
fi

# Run SignalP
if ! [ -z "$SIGNALP" ]
then
        if [ -d "$OUT/signalp" ]
        then
                echo "${GREEN}SignalP has already been run. Skipping${NORM}"
        else
                mkdir ${OUT}/signalp
                echo "${GREEN}Running SignalP${NORM}"
                THIS=$(grep "signalp: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/signalp/output@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_ORG@${SIGNALP}@;s@ANNOTATION_TMP@${OUT}/tmp@")
                $THIS
        fi
fi

# Run antiSMASH
if "$ANTISMASH"
then
        if [ -d "$OUT/antismash" ]
        then
                echo "${GREEN}antiSMASH has already been run. Skipping${NORM}"
        else
                mkdir ${OUT}/antismash
                echo "${GREEN}Running antiSMASH${NORM}"
		NEWPATH=$(grep "antismash_conda: " $CONFIG | awk '{$1=""; print $0}' | sed 's/ //')
		echo "export PATH="$NEWPATH":$PATH" > $OUT/newpath.sh
		source ${OUT}/newpath.sh
		rm ${OUT}/newpath.sh
                THIS=$(grep "antismash: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/antismash@;s@ANNOTATION_GBK@${OUT}/prokka/*\.gbk@")
                $THIS
        fi
fi

# Run RGI
if "$RGI"
then
        if [ -d "$OUT/rgi" ]
        then
                echo "${GREEN}RGI(CARD) has already been run. Skipping${NORM}"
        else
                mkdir ${OUT}/rgi
                echo "${GREEN}Running RGI(CARD)${NORM}"
                THIS=$(grep "rgi: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/rgi/card@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@")
                $THIS
        fi
fi

### Put things together
echo "${GREEN}Parsing output${NORM}"
mkdir -p ${OUT}/parsed_tables

# Prokka
grep "ID=" ${OUT}/prokka/*.gff \
	| awk -F'\t' '{print $9}' \
	| awk -F";" 'BEGIN {OFS="\t"}{for(i=1;i<=NF;i++){if ($i ~ /product=/){print $1,$i}}}' \
	| sed 's/ID=//;s/product=//' > ${OUT}/parsed_tables/prokka.tab
cp ${OUT}/parsed_tables/prokka.tab ${OUT}/temp.tab
HEADER="#CDS\tAnnotation_prokka"

# KOfam
if ! [ -z "$KOFAM" ]
then
	sed 's/^*/ /' ${OUT}/kofam/results \
        	| tail -n +3 \
		| awk 'BEGIN {OFS="\t"}1' \
		| sort -k1,1 -u > ${OUT}/parsed_tables/kofam.tab

	awk -v e=${KOFAM} '$5 < e' ${OUT}/parsed_tables/kofam.tab > ${OUT}/temp1.tab
	if ! [ -s "${OUT}/temp1.tab" ]
        then
                printf "X_00001\tNA\n\tNA" > ${OUT}/ka
	else
		awk '{print $1=$2=$3=$4=$5=""; print $0}' ${OUT}/temp1.tab \
                | awk 'NF>0' \
                | paste <(awk 'BEGIN {OFS="\t"}{print $1,$2}' ${OUT}/temp1.tab) - > ${OUT}/ka
        fi
	join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/ka > ${OUT}/temp1.tab
	mv ${OUT}/temp1.tab ${OUT}/temp.tab
	rm ${OUT}/ka
	HEADER=${HEADER}"\tKO_KOfam\tAnnotation_KOfam"
fi

# dbCAN2
if "$DBCAN"
then
	if [[ $(wc -l <${OUT}/dbcan2/overview.txt) -gt 1 ]]
	then
		Rscript ${DIR}/parse_cazy.R ${OUT}/dbcan2/overview.txt ${OUT}/parsed_tables/dbcan2.tabx
        	sort -k1,1 ${OUT}/parsed_tables/dbcan2.tabx | awk 'BEGIN {OFS="\t"}1' > ${OUT}/parsed_tables/dbcan2.tab
		rm ${OUT}/parsed_tables/dbcan2.tabx
        	awk '$7 > 1' ${OUT}/parsed_tables/dbcan2.tab | awk 'BEGIN {OFS="\t"}{print $1,$6}' > ${OUT}/da1
        	awk -F'\t' 'BEGIN {OFS="\t"}{print $9,$2}' ${OUT}/dbcan2/cgc.out \
                	| awk 'NF>0' \
                	| awk '$2 != "null"' \
                	| sort -k1,1  > ${OUT}/da2
	else
		printf "X_00001\tNA\n" > ${OUT}/da1
		printf "X_00001\tNA\n" > ${OUT}/da2
		touch ${OUT}/parsed_tables/dbcan2.tab
	fi
	join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/da1 > ${OUT}/temp1.tab
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp1.tab ${OUT}/da2 > ${OUT}/temp.tab
        rm ${OUT}/da1 ${OUT}/da2 ${OUT}/temp1.tab
	HEADER=${HEADER}"\tCAZy\tCGC"
fi

# eggNOG
if ! [ -z "$EGGNOG" ]
then
	grep -v '^#' ${OUT}/eggnog/annotation.emapper.annotations \
		| sed 's/ko://g' > $OUT/parsed_tables/eggnog.tab
	awk -v k="$EGGNOG" '$3<k' $OUT/parsed_tables/eggnog.tab \
		| awk -F'\t' 'BEGIN { OFS = "\t" }{print $1, $9, $6}' > ${OUT}/ea
        if ! [ -s "${OUT}/ea" ]
        then
                printf "X_00001\tNA\tNA\n" > ${OUT}/ea
        fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/ea > ${OUT}/temp1.tab
        rm ${OUT}/ea
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tKO_eggNOG\tAnnotation_eggNOG"
fi

# Merops
if ! [ -z "$MEROPS" ]
then
	sort -k1,1 -k11,11g ${OUT}/merops/matches.m8 \
		| sort -u -k1,1 \
		| awk 'BEGIN {OFS="\t"}1' > ${OUT}/parsed_tables/merops.tab
	awk -v k=${MEROPS} 'BEGIN {OFS="\t"} $11<k {print $1,$2}' ${OUT}/parsed_tables/merops.tab > ${OUT}/ma
	if ! [ -s "${OUT}/ma" ]
        then
                printf "X_00001\tNA\n" > ${OUT}/ma
        fi
	join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/ma > ${OUT}/temp1.tab
        rm ${OUT}/ma
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tMEROPS"
fi

# SignalP
if ! [ -z "$SIGNALP" ]
then
	grep -v '^#' ${OUT}/signalp/output_summary.signalp5 \
		| awk 'BEGIN {OFS="\t"}1' > ${OUT}/parsed_tables/signalp.tab
	awk 'BEGIN {OFS="\t"}{print $1,$2}' ${OUT}/parsed_tables/signalp.tab > ${OUT}/sa
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/sa > ${OUT}/temp1.tab
        rm ${OUT}/sa
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tSignalP"
fi

# antiSMASH
if "$ANTISMASH"
then
	if ! [ -z ${OUT}/antismash/geneclusters.txt ]
	then
		printf "X_00001\tNA\n" > ${OUT}/aa
	else
		awk -F'\t' '{print $3,$4}' ${OUT}/antismash/geneclusters.txt \
			| awk '{print $1 "_" NR, $2}' \
			| awk '{gsub(";","\n"$1"\t")}1' \
			| awk 'BEGIN {OFS="\t"}{print $2,$1}' > ${OUT}/aa
		sed 's/_\([0-9]*\)$/\t\1/' ${OUT}/aa > ${OUT}/parsed_tables/antismash.tab
	fi
	if ! [ -s "${OUT}/aa" ]
	then
		printf "X_00001\tNA\n" > ${OUT}/aa
	fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/aa > ${OUT}/temp1.tab
        rm ${OUT}/aa
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tantiSMASH"
fi

# RGI
if "$RGI"
then
	if [[ $(wc -l <${OUT}/rgi/card.txt) -gt 1 ]]
	then
		tail -n+2 ${OUT}/rgi/card.txt \
			| awk -F'\t' 'BEGIN {OFS="\t"}{print $1,$2}' \
			| sort -k1,1 > ${OUT}/parsed_tables/rgi.tab
	else
		printf "X_00001\tNA\n" > ${OUT}/parsed_tables/rgi.tab
	fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/parsed_tables/rgi.tab > ${OUT}/temp1.tab
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tRGI"
fi


### Adding headers
cat <(printf "#./annotate ") <(echo ${CLI}) <(printf "#") <(date) <(printf ${HEADER}"\n") ${OUT}/temp.tab > ${OUT}/overview.tab
rm ${OUT}/temp.tab

# Make README
printf "#### HEADERS overview.tab ####
CDS: Gene name given by prokka
Annotation_prokka: Annotation by prokka

If KOfam added:
KO_KOfam: KEGG Ortholog predicted by KOfam_scan
Annotaion_KOfam: Annotation by KOfam_scan

If dbCAN2 added:
CAZy: CAZyme family ID predicted by at least two tools in dbCAN2
CGC: Annotation by CAZyme-Gene-Cluster (CGC) predictor. TP=TransPorter, TC=TransCription factor, STP=Signal Transduction Protein, CAZyme=CAZymes part of CGC

If eggNOG added:
KO_eggNOG: KEGG Ortholog predicted by eggNOG-mapper
Annotation_eggNOG: Annotation predicted by eggNOG-mapper

If MEROPS added:
MEROPS: MEROPS identifier

If SignalP added:
SignalP: SignalP identifier

If antiSMASH added:
antiSMASH: Pred_X, where Pred is cluster prediction and X is a unique number for each cluster

If RGI(CARD) added:
RGI: Prediction from RGI(CARD)

#### HEADERS parsed_tables ####
# prokka:
CDS
Annotation

# kofam:
CDS
KEGG Ortholog
Match length
Similarity
E-value
Annotation

# dbcan2:
CDS
HMMER annotation
HotPep annotation
Diamond annotation
Consensus annotation
Consensus size (# Tools)

# eggnog:
CDS
seed_eggNOG_ortholog
seed_ortholog_evalue
seed_ortholog_score
best_tax_level
Preferred_name
GOs
EC
KEGG_ko
KEGG_Pathway
KEGG_Module
KEGG_Reaction
KEGG_rclass
BRITE
KEGG_TC
CAZy
BiGG_Reaction
Kingdom
?
?
?
Description

# merops:
CDS
MEROPS ID
Percent identical
Alignment length
Number of mismatches
Number of gaps
Start of query
End of query
Start of alignment in subject
End of alignment in subject
E-value
Bitscore

# signalp:
CDS
Annotation
SP probability
TAT probability
LIPO probability
OTHER probability
Cleavage site (CS)

# antismash:
CDS
antiSMASH annotation
Cluster ID

# rgi
CDS
Contig
Start
Stop
Orientation
Cut_Off Pass_Bitscore
Best_Hit_Bitscore
Best_Hit_ARO
Best_IdentitiesARO
Model_type
SNPs_in_Best_Hit_ARO
Other_SNPs
Drug Class
Resistance Mechanism
AMR Gene Family Predicted_DN
Predicted_Protein
CARD_Protein_Sequence
Percentage Length of Reference Sequence ID
Model_ID

#### Versions ####
KOfamScan 1.0.0
KEGG release 90.0

run_dbcan 2.0
Database from Apr 4th 2019

emapper-1.0.3-33-g70ff1ab
Database from Mar 19th 2019

MEROPS release 12.0

SignalP 5.0

Remaining version can be found in the environment.yml

" > ${OUT}/README.txt

echo "${GREEN}Done!${NORM}"


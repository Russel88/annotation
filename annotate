#!/bin/bash

# Master script for running annotation pipeline

# Usage message
usage() { printf "
..... Annotation pipeline .....
........ Version 0.0.2 ........
......... Jakob Russel ........
........... 2019 May ..........

Usage:
 ./annotate [-i my.fasta] [-o /my/output/dir]

Optional arguments:
[-c /path/to/alternative/config/file] Change the config.yml file to change specific options in the different tools (default: /mibi/users/russel/Software/annotation/config.yml)
[-r] resume (e.g. to add new annotation tools or create new output table with different e-value cutoffs)

Arguments to add tools:
[-d] Adds dbcan2 for CAZyme and CAZyme Gene Cluster (CGC) prediction
[-e <e-value>] Adds eggNOG for KEGG orthologs and annotations. Choose e-value cutoff
[-n] Adds RGI for Antibiotic resistance prediction against CARD
[-m <e-value>] Adds diamond search against MEROPS database for peptidase prediction. Choose e-value cutoff
[-a] Adds antiSMASH prediction for secondary metabolite production
[-k <e-value>] Adds KOfam_scan for KEGG orthologs and annotations. Choose e-value cutoff
[-s <string>] Adds SignalP prediction. Choose organism: arch, gram+, or gram-
[-t <e-value>] Adds Transposase prediction (TnpPred). Choose e-value cutoff
[-x <e-value>] Adds CasFinder for CRISPR-associated gene prediction. Choose e-value cutoff

Example:
 ./annotate -i my.fasta -o /my/output/dir -d -e 1e-10 -n -m 1e-20 -a -r -k 1e-10 -s gram+

" 1>&2; exit 1; }
GREEN=$(tput setaf 2)
NORM=$(tput sgr0)

CLI=$*
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

# Get arguments
RESUME=false
DBCAN=false
ANTISMASH=false
RGI=false

while getopts ":o:i:c:k:m:s:e:t:x:rdan" opt
do
  case $opt in
    o) OUT="$OPTARG";;
    i) FAS="$OPTARG";;
    c) CONFIG="$OPTARG";;
    r) RESUME=true;;
    k) KOFAM="$OPTARG";;
    d) DBCAN=true;;
    e) EGGNOG="$OPTARG";;
    m) MEROPS="$OPTARG";;
    s) SIGNALP="$OPTARG";;
    a) ANTISMASH=true;;
    n) RGI=true;;
    t) TNPPRED="$OPTARG";;
    x) CAS="$OPTARG";;
    :) echo "Missing option argument for -$OPTARG"; usage;;
    *) usage;;
  esac
done

shift $((OPTIND-1))

# Check arguments
if [ -z "${OUT}" ] || [ -z "${FAS}" ]
then
    usage
fi

if [ -z "${CONFIG}" ]
then
    CONFIG="${DIR}/config.yml"
fi

if ! [[ "${OUT}" == /* ]]
then
	OUT=${PWD}/${OUT}
fi

# Check output dir
if [ -d "$OUT" ] && ! "$RESUME"
then
    	printf "Output directory already exists! Terminating\nUse [-r] argument to add tools to existing dir and/or remake output with new e-value cutoffs\n"
	exit 1
else
	mkdir -p $OUT
fi

# Run Prokka
if [ -d "${OUT}/prokka" ]
then
	echo "${GREEN}prokka has already been run. Skipping${NORM}"
else
	mkdir ${OUT}/tmp
	echo "${GREEN}Running Prokka${NORM}"
	THIS=$(grep "prokka: " $CONFIG \
        	| awk '{$1=""; print $0}' \
        	| sed "s@ANNOTATION_OUT@${OUT}/prokka@;s@ANNOTATION_FAS@${FAS}@")
	$THIS
fi

if ! [ -f "${OUT}/prokka/"*.faa ]
then
	echo Prokka failed. Terminating
	exit 1
fi

# Run KOfam scan
if ! [ -z "$KOFAM" ]
then
	if [ -d "$OUT/kofam" ]
	then
		echo "${GREEN}KOfam scan has already been run. Skipping${NORM}"
	else
		echo "${GREEN}Running KOfam scan${NORM}"
		THIS=$(grep "kofam: " $CONFIG \
	        	| awk '{$1=""; print $0}' \
	        	| sed "s@ANNOTATION_OUT@${OUT}/results@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_TMP@${OUT}/tmp@")
		$THIS
		mkdir ${OUT}/kofam
		mv ${OUT}/results ${OUT}/kofam/results
		mv ${OUT}/tmp/tabular/ ${OUT}/kofam
	fi
fi

# Run dbCAN2
if "$DBCAN"
then
        if [ -d "$OUT/dbcan2" ]
        then
                echo "${GREEN}dbCAN2 has already been run. Skipping${NORM}"
        else
                echo "${GREEN}Running dbCAN2${NORM}"
		grep "ID=" ${OUT}/prokka/*\.gff > ${OUT}/prokka/trimmed.gff2
		mkdir ${OUT}/dbcan2
                THIS=$(grep "dbcan: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/dbcan2@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_GFF@${OUT}/prokka/trimmed.gff2@")
                $THIS
        fi
fi

# Run eggNOG
if ! [ -z "$EGGNOG" ]
then
        if [ -d "$OUT/eggnog" ]
        then
                echo "${GREEN}eggNOG-mapper has already been run. Skipping${NORM}"
        else
                echo "${GREEN}Running eggNOG-mapper. Warning! This is slow!${NORM}"
                mkdir ${OUT}/eggnog
                THIS=$(grep "eggnog: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/eggnog@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_TMP@${OUT}/tmp@")
                $THIS
        fi
fi

# Run MEROPS
if ! [ -z "$MEROPS" ]
then
	if [ -d "$OUT/merops" ]
        then
                echo "${GREEN}Merops search has already been run. Skipping${NORM}"
        else
		mkdir ${OUT}/merops
                echo "${GREEN}Running diamond search against MEROPS${NORM}"
                THIS=$(grep "merops: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/merops/matches.m8@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@")
                $THIS
        fi
fi

# Run SignalP
if ! [ -z "$SIGNALP" ]
then
	case ${SIGNALP} in
		arch|gram+|gram-) :  ;;
		*) echo "Error. [-s] argument has to be one of arch|gram+|gram-" && exit 1 ;;
	esac
        if [ -d "$OUT/signalp" ]
        then
                echo "${GREEN}SignalP has already been run. Skipping${NORM}"
        else
                mkdir ${OUT}/signalp
                echo "${GREEN}Running SignalP${NORM}"
                THIS=$(grep "signalp: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/signalp/output@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_ORG@${SIGNALP}@;s@ANNOTATION_TMP@${OUT}/tmp@")
                $THIS
        fi
fi

# Run antiSMASH
if "$ANTISMASH"
then
        if [ -d "$OUT/antismash" ]
        then
                echo "${GREEN}antiSMASH has already been run. Skipping${NORM}"
        else
                mkdir ${OUT}/antismash
                echo "${GREEN}Running antiSMASH${NORM}"
		NEWPATH=$(grep "antismash_conda: " $CONFIG | awk '{$1=""; print $0}' | sed 's/ //')
		echo "export PATH="$NEWPATH":$PATH" > $OUT/newpath.sh
		source ${OUT}/newpath.sh
		rm ${OUT}/newpath.sh
                THIS=$(grep "antismash: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/antismash@;s@ANNOTATION_GBK@${OUT}/prokka/*\.gbk@")
                $THIS
        fi
fi

# Run RGI
if "$RGI"
then
        if [ -d "$OUT/rgi" ]
        then
                echo "${GREEN}RGI(CARD) has already been run. Skipping${NORM}"
        else
                mkdir ${OUT}/rgi
                echo "${GREEN}Running RGI(CARD)${NORM}"
                THIS=$(grep "rgi: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/rgi/card@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@")
                $THIS
        fi
fi

# Run TnpPred
if ! [ -z "$TNPPRED" ]
then
        if [ -d "$OUT/tnppred" ]
        then
                echo "${GREEN}TnpPred has already been run. Skipping${NORM}"
        else
                mkdir ${OUT}/tnppred
                echo "${GREEN}Running TnpPred${NORM}"
                THIS=$(grep "tnppred: " $CONFIG \
                        | awk '{$1=""; print $0}' \
                        | sed "s@ANNOTATION_OUT@${OUT}/tnppred/output.tab@;s@ANNOTATION_FAS@${OUT}/prokka/*\.faa@;s@ANNOTATION_TMP@${OUT}/tnppred/hmmscan.txt@")
		$THIS
        fi
fi

# Run against CasFinder HMMs
if ! [ -z "$CAS" ]
then
        if [ -d "$OUT/casfinder" ]
        then
                echo "${GREEN}CasFinder HMMs has already been searched. Skipping${NORM}"
        else
                mkdir -p ${OUT}/casfinder
                echo "${GREEN}Running against CasFinder HMMs${NORM}"
		export CASFAS=$(echo ${OUT}/prokka/*.faa)
		export CASOUT=$(echo ${OUT}/casfinder)
		doit() {
		name=$(echo $1 | sed "s|.*\/||;s|\.hmm||")
                hmmscan --tblout ${CASOUT}/${name}.tab -o ${CASOUT}/${name}.out $1 $CASFAS
		}
		export -f doit
		parallel -j10 doit {} ::: /mibi/users/russel/Databases/casprofiles_2.0.2/*.hmm
        fi
fi

### Put things together
echo "${GREEN}Parsing output${NORM}"
mkdir -p ${OUT}/parsed_tables

# Prokka
grep "ID=" ${OUT}/prokka/*.gff \
	| awk -F'\t' '{print $9}' \
	| awk -F";" 'BEGIN {OFS="\t"}{for(i=1;i<=NF;i++){if ($i ~ /product=/){print $1,$i}}}' \
	| sed 's/ID=//;s/product=//' \
	| paste - <(grep "ID=" ${OUT}/prokka/*.gff \
		| awk 'BEGIN{OFS="_"}{print $1,$4,$5}' \
		| sed 's/.*|X_//') |
	awk -F'\t' 'BEGIN{OFS="\t"}{print $1,$3,$2}'> ${OUT}/parsed_tables/prokka.tab

cp ${OUT}/parsed_tables/prokka.tab ${OUT}/temp.tab
HEADER="#CDS\tContig_Position\tAnnotation_prokka"
cat <(printf ${HEADER}"\n") ${OUT}/temp.tab > ${OUT}/parsed_tables/prokka.tab

# KOfam
if ! [ -z "$KOFAM" ]
then
	tail -n +3 ${OUT}/kofam/results \
        	| sed 's/^*/ /' \
		| awk 'BEGIN {OFS="\t"}1' \
		| sort -k1,1 -u > ${OUT}/parsed_tables/kofam.tab

	awk -v e=${KOFAM} '$5 < e' ${OUT}/parsed_tables/kofam.tab > ${OUT}/temp1.tab
	if ! [ -s "${OUT}/temp1.tab" ]
        then
                printf "X_00001\tNA\n\tNA" > ${OUT}/ka
	else
		awk '{print $1=$2=$3=$4=$5=""; print $0}' ${OUT}/temp1.tab \
                | awk 'NF>0' \
                | paste <(awk 'BEGIN {OFS="\t"}{print $1,$2}' ${OUT}/temp1.tab) - > ${OUT}/ka
        fi
	join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/ka > ${OUT}/temp1.tab
	mv ${OUT}/temp1.tab ${OUT}/temp.tab
	rm ${OUT}/ka
	HEADER=${HEADER}"\tKO_KOfam\tAnnotation_KOfam"
	cat <(printf "#CDS\tKO\tMatch_length\tSimilarity\tE-value\tAnnotation\n") ${OUT}/parsed_tables/kofam.tab > ${OUT}/parsed_tables/kofam.tab1
	mv ${OUT}/parsed_tables/kofam.tab1 ${OUT}/parsed_tables/kofam.tab
fi

# dbCAN2
if "$DBCAN"
then
	if [[ $(wc -l <${OUT}/dbcan2/overview.txt) -gt 1 ]]
	then
		Rscript ${DIR}/parse_cazy.R ${OUT}/dbcan2/overview.txt ${OUT}/parsed_tables/dbcan2.tabx
        	sort -k1,1 ${OUT}/parsed_tables/dbcan2.tabx | awk 'BEGIN {OFS="\t"}1' > ${OUT}/parsed_tables/dbcan2.tab
		rm ${OUT}/parsed_tables/dbcan2.tabx
        	awk '$7 > 1' ${OUT}/parsed_tables/dbcan2.tab | awk 'BEGIN {OFS="\t"}{print $1,$6}' > ${OUT}/da1
        	awk -F'\t' 'BEGIN {OFS="\t"}{print $9,$2}' ${OUT}/dbcan2/cgc.out \
                	| awk 'NF>0' \
                	| awk '$2 != "null"' \
                	| sort -k1,1  > ${OUT}/da2
	else
		printf "X_00001\tNA\n" > ${OUT}/da1
		printf "X_00001\tNA\n" > ${OUT}/da2
		touch ${OUT}/parsed_tables/dbcan2.tab
	fi
	join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/da1 > ${OUT}/temp1.tab
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp1.tab ${OUT}/da2 > ${OUT}/temp.tab
        rm ${OUT}/da1 ${OUT}/da2 ${OUT}/temp1.tab
	HEADER=${HEADER}"\tCAZy\tCGC"
	cat <(printf "#CDS\tHMMER_annotation\tHotPep_annotation\tDiamond_annotation\tConsensus_annotation\n") ${OUT}/parsed_tables/dbcan2.tab > ${OUT}/parsed_tables/dbcan2.tab1
	mv ${OUT}/parsed_tables/dbcan2.tab1 ${OUT}/parsed_tables/dbcan2.tab
fi

# eggNOG
if ! [ -z "$EGGNOG" ]
then
	grep -v '^#' ${OUT}/eggnog/annotation.emapper.annotations \
		| sed 's/ko://g' > $OUT/parsed_tables/eggnog.tab
	awk -v k="$EGGNOG" '$3<k' $OUT/parsed_tables/eggnog.tab \
		| awk -F'\t' 'BEGIN { OFS = "\t" }{print $1, $9, $5, $6}' > ${OUT}/ea
        if ! [ -s "${OUT}/ea" ]
        then
                printf "X_00001\tNA\tNA\nNA\n" > ${OUT}/ea
        fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/ea > ${OUT}/temp1.tab
        rm ${OUT}/ea
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tKO_eggNOG\tTax_eggNOG\tAnnotation_eggNOG"
	cat <(sed -n '4p' ${OUT}/eggnog/annotation.emapper.annotations | sed 's/query_name/CDS/') $OUT/parsed_tables/eggnog.tab > $OUT/parsed_tables/eggnog.tab1
	mv $OUT/parsed_tables/eggnog.tab1 $OUT/parsed_tables/eggnog.tab
fi

# Merops
if ! [ -z "$MEROPS" ]
then
	sort -k1,1 -k11,11g ${OUT}/merops/matches.m8 \
		| sort -u -k1,1 \
		| awk 'BEGIN {OFS="\t"}1' > ${OUT}/parsed_tables/merops.tab
	awk -v k=${MEROPS} 'BEGIN {OFS="\t"} $11<k {print $1,$2}' ${OUT}/parsed_tables/merops.tab > ${OUT}/ma
	if ! [ -s "${OUT}/ma" ]
        then
                printf "X_00001\tNA\n" > ${OUT}/ma
        fi
	join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/ma > ${OUT}/temp1.tab
        rm ${OUT}/ma
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tMEROPS"
	cat <(printf "#CDS\tMEROPS\tPct_id\tAlign_length\tMismatches\tGaps\tQuery_start\tQuery_end\tSubject_start\tSubject_end\tE-value\tBit_score\n") ${OUT}/parsed_tables/merops.tab > ${OUT}/parsed_tables/merops.tab1
	mv ${OUT}/parsed_tables/merops.tab1 ${OUT}/parsed_tables/merops.tab
fi

# SignalP
if ! [ -z "$SIGNALP" ]
then
	grep -v '^#' ${OUT}/signalp/output_summary.signalp5 \
		| awk 'BEGIN {OFS="\t"}1' > ${OUT}/parsed_tables/signalp.tab
	awk 'BEGIN {OFS="\t"}{print $1,$2}' ${OUT}/parsed_tables/signalp.tab > ${OUT}/sa
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/sa > ${OUT}/temp1.tab
        rm ${OUT}/sa
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tSignalP"
	cat <(printf "#CDS\tAnnotation\tSP_probability\tTAT_probability\tLIPO_probability\tOTHER_probability\tCleavage_site\n") ${OUT}/parsed_tables/signalp.tab > ${OUT}/parsed_tables/signalp.tab1
	mv ${OUT}/parsed_tables/signalp.tab1 ${OUT}/parsed_tables/signalp.tab
fi

# antiSMASH
if "$ANTISMASH"
then
	if ! [ -s ${OUT}/antismash/geneclusters.txt ]
	then
		printf "X_00001\tNA\n" > ${OUT}/aa
	else
		awk -F'\t' '{print $3,$4}' ${OUT}/antismash/geneclusters.txt \
			| awk '{print $1 "_" NR, $2}' \
			| awk '{gsub(";","\n"$1"\t")}1' \
			| awk 'BEGIN {OFS="\t"}{print $2,$1}' > ${OUT}/aa
		sed 's/_\([0-9]*\)$/\t\1/' ${OUT}/aa > ${OUT}/parsed_tables/antismash.tab
	fi
	if ! [ -s "${OUT}/aa" ]
	then
		printf "X_00001\tNA\n" > ${OUT}/aa
	fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/aa > ${OUT}/temp1.tab
        rm ${OUT}/aa
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tantiSMASH"
	cat <(printf "#CDS\tAnnotation\tCluster_ID\n") ${OUT}/parsed_tables/antismash.tab > ${OUT}/parsed_tables/antismash.tab1 
	mv ${OUT}/parsed_tables/antismash.tab1 ${OUT}/parsed_tables/antismash.tab
fi

# RGI
if "$RGI"
then
	if [[ $(wc -l <${OUT}/rgi/card.txt) -gt 1 ]]
	then
		tail -n+2 ${OUT}/rgi/card.txt \
			| awk -F'\t' 'BEGIN {OFS="\t"}{print $1,$2}' \
			| sort -k1,1 > ${OUT}/parsed_tables/rgi.tab
	else
		printf "X_00001\tNA\n" > ${OUT}/parsed_tables/rgi.tab
	fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/parsed_tables/rgi.tab > ${OUT}/temp1.tab
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tRGI"
	cat <(printf "#CDS\tAnnotation\n") ${OUT}/parsed_tables/rgi.tab > ${OUT}/parsed_tables/rgi.tab1
	mv ${OUT}/parsed_tables/rgi.tab1 ${OUT}/parsed_tables/rgi.tab
fi

# TnpPred
if ! [ -z "$TNPPRED" ]
then
	grep -v "^#" ${OUT}/tnppred/output.tab \
		| sort -k3,3 -k5,5g \
		| sort -k3,3 -u \
		| awk 'BEGIN {OFS="\t"}{print $3,$1,$5}' > ${OUT}/parsed_tables/tnppred.tab
	awk -v k="${TNPPRED}" 'BEGIN {OFS="\t"} $3<k {print $1,$2}' ${OUT}/parsed_tables/tnppred.tab \
		| sort -k1,1 > ${OUT}/ta
	if ! [ -s "${OUT}/ta" ]
        then
                printf "X_00001\tNA\n" > ${OUT}/ta
        fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/ta > ${OUT}/temp1.tab
        rm ${OUT}/ta
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tTnpPred"
	cat <(printf "#CDS\tTnpPredHMM\tE-value\n") ${OUT}/parsed_tables/tnppred.tab > ${OUT}/parsed_tables/tnppred.tab1
	mv ${OUT}/parsed_tables/tnppred.tab1 ${OUT}/parsed_tables/tnppred.tab
fi

# CasFinder
if ! [ -z "$CAS" ]
then
        grep -v "^#" ${OUT}/casfinder/*.tab \
                | sort -k3,3 -k5,5g \
                | sort -k3,3 -u \
                | awk '{gsub(".tab.*","",$1)}1' \
		| awk '{gsub(".*/","",$1)}1' \
		| awk 'BEGIN {OFS="\t"}{print $3,$1,$5}'> ${OUT}/parsed_tables/casfinder.tab
        awk -v k="${CAS}" 'BEGIN {OFS="\t"} $3<k {print $1,$2}' ${OUT}/parsed_tables/casfinder.tab \
		| sort -k1,1 > ${OUT}/xa
        if ! [ -s "${OUT}/xa" ]
        then
                printf "X_00001\tNA\n" > ${OUT}/xa
        fi
        join -t $'\t' -j 1 -a 1 -o auto -e "NA" ${OUT}/temp.tab ${OUT}/xa > ${OUT}/temp1.tab
	rm ${OUT}/xa
        mv ${OUT}/temp1.tab ${OUT}/temp.tab
        HEADER=${HEADER}"\tCasFinder"
	cat <(printf "#CDS\tCasHMM\tE-value\n") ${OUT}/parsed_tables/casfinder.tab > ${OUT}/parsed_tables/casfinder.tab1
	mv ${OUT}/parsed_tables/casfinder.tab1 ${OUT}/parsed_tables/casfinder.tab
fi



### Adding headers
cat <(printf "#./annotate ") <(echo ${CLI}) <(printf "#") <(date) <(printf ${HEADER}"\n") ${OUT}/temp.tab > ${OUT}/overview.tab
rm ${OUT}/temp.tab

# Make README
printf "#### Version 0.0.1 ####

#### HEADERS overview.tab ####
CDS: Gene name given by prokka
Contig_Position: Contig and position on contig of CDS
Annotation_prokka: Annotation by prokka

If KOfam added:
KO_KOfam: KEGG Ortholog predicted by KOfam_scan
Annotaion_KOfam: Annotation by KOfam_scan

If dbCAN2 added:
CAZy: CAZyme family ID predicted by at least two tools in dbCAN2
CGC: Annotation by CAZyme-Gene-Cluster (CGC) predictor. TP=TransPorter, TC=TransCription factor, STP=Signal Transduction Protein, CAZyme=CAZymes part of CGC

If eggNOG added:
KO_eggNOG: KEGG Ortholog predicted by eggNOG-mapper
Tax_eggNOG: Best tax level
Annotation_eggNOG: Annotation predicted by eggNOG-mapper

If MEROPS added:
MEROPS: MEROPS identifier

If SignalP added:
SignalP: SignalP identifier

If antiSMASH added:
antiSMASH: Pred_X, where Pred is cluster prediction and X is a unique number for each cluster

If RGI(CARD) added:
RGI: Prediction from RGI(CARD)

If TnpPred added:
TnpPred: Prediction from hmmscan against TnpPred

If CasFinder added
CasFinder: Best Cas HMM hit

#### Versions ####
KOfamScan 1.0.0
KEGG release 90.0

run_dbcan 2.0
Database from Apr 4th 2019

emapper-1.0.3-33-g70ff1ab
Database from Mar 19th 2019

MEROPS release 12.0

SignalP 5.0

CasFinder 2.0.2 HMMs

Remaining version can be found in the environment.yml

" > ${OUT}/README.txt

echo "${GREEN}Done!${NORM}"

